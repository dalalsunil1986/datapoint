<?php
require_once('datapoint.inc');
require_once('datapoint.vertex-install.inc');

function datapoint_init() {
}

function datapoint_nodeapi(&$node, $op) {
  if ($op=='load') {
    $res = db_query("SELECT * FROM {datapoint} WHERE nid=%s", $node->nid);
    if ($dp = db_fetch_object($res)) {
      if (!empty($dp->data)) {
        $dp->data = unserialize($dp->data);
      }
      else {
        $dp->data = array();
      }
      $node->datapoint = $dp;
    }
  }
}

function datapoint_cron() {
  set_time_limit(0);
  require_once('datapoint.admin.inc');

  //Update sources that never have been updated or haven't been updated in one hour, limit to five
  $res = db_query_range("SELECT sid FROM {datapoint_source}
    WHERE last_update<%d
    ORDER BY pinged DESC,
      last_update ASC", time()-(60*60*2), 0, 5);
  if ($o = db_fetch_object($res)) {
    datapoint_update_source($o->sid);
  }

  //Update and create nodes
  datapoint_update_nodes();
}

function datapoint_update_source($sid) {
  $source = datapoint_source($sid);

  if ($source) {
    $parser = datapoint_parser_info($source['parser']);
    if (is_callable($parser['fetch'])) {
      require_once('datapoint.inc');
      $results = new DatapointResults();
      call_user_func($parser['fetch'], $source, $results);

      // Store the results from the fetch
      datapoint_store($source, $results);

      // Mark the source as updated, and clear ping flag
      db_query("UPDATE {datapoint_source} SET pinged=0, last_update=%d WHERE sid=%d", time(), $sid);
    }
    return TRUE;
  }
  else {
    return FALSE;
  }
}

/**
 * Implementation of hook_menu
 *
 * @return array
 **/
function datapoint_menu() {
  $menu = array();
  $menu['admin/content/datapoint'] = array(
    'title' => 'Data points',
    'page callback' => '_datapoint_admin_index_page',
    'access arguments' => array('administer datapoint sources'),
    'file' => 'datapoint.admin.inc',
    'type' => MENU_NORMAL_ITEM,
  );
  $menu['admin/content/datapoint/add-source'] = array(
    'title' => 'Add new data point source',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('_datapoint_source_add'),
    'access arguments' => array('administer datapoint sources'),
    'file' => 'datapoint.admin.inc',
    'type' => MENU_NORMAL_ITEM,
  );
  $menu['admin/content/datapoint/source-types'] = array(
    'title' => 'Source types',
    'page callback' => '_datapoint_admin_source_types',
    'access arguments' => array('administer datapoint sources'),
    'file' => 'datapoint.admin.inc',
    'type' => MENU_NORMAL_ITEM,
  );
  $menu['admin/content/datapoint/source-types/add'] = array(
    'title' => 'Add source type',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('_datapoint_admin_add_source_type'),
    'access arguments' => array('administer datapoint sources'),
    'file' => 'datapoint.admin.inc',
    'type' => MENU_NORMAL_ITEM,
  );
  $menu['admin/content/datapoint/source-types/add/%/%'] = array(
    'title' => 'Source type settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('_datapoint_admin_add_source_type_configure', 5, 6),
    'access arguments' => array('administer datapoint sources'),
    'file' => 'datapoint.admin.inc',
    'type' => MENU_CALLBACK,
  );

  $menu['admin/content/datapoint/source-types/export/%'] = array(
    'page callback' => 'datapoint_export_source_type',
    'page arguments' => array(5),
    'access arguments' => array('access content'),
    'file' => 'datapoint.admin.inc',
    'type' => MENU_CALLBACK,
  );

  $menu['admin/content/datapoint/source/export/%'] = array(
    'page callback' => 'datapoint_export_source',
    'page arguments' => array(5),
    'access arguments' => array('access content'),
    'file' => 'datapoint.admin.inc',
    'type' => MENU_CALLBACK,
  );

  $menu['admin/content/datapoint/cron'] = array(
    'page callback' => 'datapoint_cron',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );

  $menu['admin/content/datapoint/update-nodes'] = array(
    'page callback' => 'datapoint_update_nodes',
    'access arguments' => array('administer datapoint sources'),
    'type' => MENU_CALLBACK,
  );

  // Ping
  $menu['datapoint/ping/%'] = array(
    'page callback' => 'datapoint_ping',
    'page arguments' => array(2),
    'access arguments' => array('access content'),
    'file' => 'datapoint.admin.inc',
  );

  // Ahah callbacks
  $menu['datapoint/ahah/field-source-configuration/%/%'] = array(
    'page callback' => 'datapoint_ahah_field_source_configuration',
    'page arguments' => array(3, 4),
    'access arguments' => array('administer datapoint sources'),
    'file' => 'datapoint.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $menu['datapoint/ahah/source_configuration'] = array(
    'page callback' => 'datapoint_ahah_source_configuration',
    'access arguments' => array('administer datapoint sources'),
    'file' => 'datapoint.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $menu['datapoint/ahah/custom-node-configuration'] = array(
    'page callback' => 'datapoint_ahah_custom_node_configuration',
    'page arguments' => array(3, 4),
    'access arguments' => array('administer datapoint sources'),
    'file' => 'datapoint.admin.inc',
    'type' => MENU_CALLBACK,
  );

  return $menu;
}

/**
 * Implementation of hook_perm
 *
 * @return array
 **/
function datapoint_perm() {
  return array('administer datapoint sources');
}

/**
 * Gets the source fields that are available for the results from a specific $parser
 *
 * @return array
 **/
function datapoint_source_fields($parser) {
  static $cache = array();

  if (!isset($cache[$parser])) {
    $schema = datapoint_vertex_module_schema($parser);
    $schema_fields = $schema[$parser . '_vertex']['fields'];

    $source_fields = array(
      'datapoint_name' => array(
        'callback' => '_datapoint_source_fields',
        'description' => t('The name of the data point'),
      ),
      'datapoint_external_id' => array(
        'callback' => '_datapoint_source_fields',
        'description' => t('The external id for the data point'),
      ),
      'datapoint_data' => array(
        'callback' => '_datapoint_custom_data_source',
        'description' => t('Custom datapoint attribute'),
        'configuration_form' => '_datapoint_custom_data_source_configuration_form',
      ),
    );

    foreach ($schema_fields as $key => $column) {
      $source_fields['vertex_schema_' . $key] = array(
        'description' => $column['description'],
        'callback' => '_datapoint_source_fields',
        'vertex_attribute' => $key,
      );
    }

    drupal_alter('datapoint_source_fields', $source_fields, $parser);

    $cache[$parser] = $source_fields;
  }

  return $cache[$parser];
}

function _datapoint_custom_data_source(&$node, $field_name, $field, $source, $datapoint, $vertex) {
  $name = $field['configuration']['name'];
  if (isset($datapoint->data[$name])) {
    return $datapoint->data[$name];
  }
}

function _datapoint_custom_data_source_configuration_form($form_state, $field) {
  $form = array();
  $form['datapoint_custom_data_name'] = array(
    '#type' => 'textfield',
    '#title' => t('Attribute name'),
    '#default_value' => '',
  );
  return $form;
}

function _datapoint_custom_data_source_configuration_form_submit($field, $values) {
  return array(
    'name' => $values['datapoint_custom_data_name']
  );
}

/**
 * Common callback for all the basic source fields
 *
 * @return mixed
 **/
function _datapoint_source_fields(&$node, $field_name, $field, $source, $datapoint, $vertex) {
  switch ($field['source']) {
    case 'datapoint_name':
      return $datapoint->name;
    break;
    case 'datapoint_external_id':
      return $datapoint->external_id;
    break;
    default:
      // Check if this simply is a reference to a vertex attribute
      // TODO: Maybe this could be a viable method to get the datapoint attributes too
      if (isset($source['vertex_attribute'])) {
        $a = $source['vertex_attribute'];
        if (isset($vertex->$a)) {
          return $vertex->$a;
        }
      }
    break;
  }
}

/**
 * Loads the data point source type
 *
 * @return array Source type configuration
 **/
function datapoint_source_type($type) {
  $res = db_query("SELECT configuration FROM {datapoint_source_type} WHERE type='%s'", $type);
  if ($source = db_fetch_object($res)) {
    return unserialize($source->configuration);
  }
  return FALSE;
}

/**
 * Loads a data point source
 *
 * @return array Source configuration
 **/
function datapoint_source($sid) {
  static $cache = array();

  if (!isset($cache[$sid])) {
    $res = db_query("SELECT configuration FROM {datapoint_source} WHERE sid='%d'", $sid);
    if ($o = db_fetch_object($res)) {
      $source = unserialize($o->configuration);
      $source['sid'] = $sid;
      $cache[$sid] = $source;
    }
    else {
      return FALSE;
    }
  }

  return $cache[$sid];
}

/**
 * Loads a datapoint from the given $source with the specified external $id.
 * The $source acts as a namespace for external id:s
 *
 * @return void
 **/
function datapoint_by_external_id($source, $id) {
  $res = db_query("SELECT * FROM {datapoint} WHERE sid=%d AND external_id='%s'", $source, $id);
  if ($point = db_fetch_object($res)) {
    return $point;
  }
  return FALSE;
}

/**
 * Saves a source type configuration in the database
 *
 * @return void
 **/
function datapoint_add_source_type($configuration) {
  db_query("INSERT INTO {datapoint_source_type}(type, name, configuration) VALUES('%s','%s','%s')",
    $configuration['type'], $configuration['name'], serialize($configuration));
}

/**
 * Saves a source in the database
 *
 * @return void
 **/
function datapoint_add_source($configuration) {
  db_query("INSERT INTO {datapoint_source}(source_type, name, last_update, configuration)
    VALUES('%s','%s',0,'%s')",
    $configuration['type'], $configuration['name'], serialize($configuration));
}

/**
 * Gets the defined source types as a associative array type=>name
 *
 * @return void
 **/
function datapoint_source_types() {
  $types = array();
  $res = db_query("SELECT type, name FROM {datapoint_source_type}");
  while ($o = db_fetch_object($res)) {
    $types[$o->type] = $o->name;
  }
  return $types;
}

/**
 * Gets the fields that datapoint feeds can access in nodes of specific type
 *
 * @return void
 **/
function datapoint_managed_fields($content_type) {
  static $cache = array();

  if (!isset($cache[$content_type])) {
    $type = node_get_types('type', $content_type);
    $fields = array();
    drupal_alter('datapoint_managed_fields', $fields, $type);

    return $cache[$content_type] = $fields;
  }

  return $cache[$content_type];
}

/**
 * Implementation of hook_datapoint_managed_fields_alter
 *
 * @return void
 **/
function datapoint_datapoint_managed_fields_alter(&$fields, $type) {
  if ($type->has_title) {
    $fields['title'] = array(
      'label' => $type->title_label,
      'required' => TRUE,
      'setter' => '_datapoint_set_node_title',
    );
  }
  if ($type->has_body) {
    $fields['body'] = array(
      'label' => $type->body_label,
      'required' => $type->min_word_count>0,
      'setter' => '_datapoint_set_node_body',
    );
  }
}



/**
 * Setter for the managed field title
 *
 * @return void
 **/
function _datapoint_set_node_title(&$node, $field, $setter, $value) {
  $node->title = $value;
}

/**
 * Setter for the managed field body
 *
 * @return void
 **/
function _datapoint_set_node_body(&$node, $field, $setter, $value) {
  $node->body = $value;
}

/**
 * Helper function to fetch data from a url for a parser
 *
 * TODO: This function should be enhanced with some header stuff like etag & updated since. We should stop unchanged data from reaching the parser based on some md5 or crc check.
 *
 * @return void
 **/
function datapoint_url_fetch($url, $source, &$result, $callback) {
  // This function initializes CURL, sets the necessary CURL
  // options, executes the request and returns the results.
  $ch = curl_init();
  curl_setopt($ch, CURLOPT_URL, $url);
  curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
  $data = curl_exec($ch);
  curl_close($ch);

  call_user_func_array($callback, array($data, $source, &$result));
}

/**
 * Stores the $results for the $source. If you want to add data points and vertexes
 * programmatically this is the place to do it.
 *
 * @return void
 **/
function datapoint_store($source, &$results) {
  set_time_limit(0);
  
  require_once(drupal_get_path('module', 'datapoint') . '/datapoint.vertex-install.inc');
  $vertex_table = $source['parser'] . '_vertex';

  foreach($results as $extid => $point) {
    $dbp = datapoint_by_external_id($source['sid'], $extid);

    // If the data point exists in the database
    if ($dbp) {
      // ...delete vertexes that overlap or are later than what we're currently adding
      db_query("DELETE FROM {{$vertex_table}} WHERE pid=%d AND valid_from>=%d",
        $dbp->pid, $point->getStartTime());
      // ...update the data point
      db_query("UPDATE {datapoint} SET name='%s', data='%s', dirty=1 WHERE pid=%d",
        $point->getName(), serialize($point->getData()), $dbp->pid);
    }
    else {
      // ...otherwise we just want to add the datapoint
      db_query("INSERT INTO {datapoint}(sid, external_id, name, data, dirty) VALUES(%d, '%s', '%s', '%s', 1)",
        $source['sid'], $extid, $point->getName(), serialize($point->getData()));
      $dbp = datapoint_by_external_id($source['sid'], $extid);
    }

    // The schema information for the parser is needed to create vertexes
    $schema = datapoint_vertex_module_fields($source['parser']);

    foreach ($point as $vertex) {
      $attr = $vertex->getValues();

      // Set up our field & values arrays with the two default columns
      $fields = array('pid', 'valid_from');
      $values = array($dbp->pid, $vertex->getTime());

      // Iterate through the vertex columns
      foreach ($schema['fields'] as $cname => $cdef) {
        if (isset($attr[$cname])) { //Attributes that are provided should always be added
          $fields[] = $cname;
          $values[] = $attr[$cname];
        }
        // If no value was provided and the column is required
        else if (isset($cdef['not null']) && $cdef['not null']) {
          if (isset($cdef['default'])) { // We're saved by a default value
            $fields[] = $cname;
            $values[] = $cdef['default'];
          }
          else { // The vertex is not valid so we're skipping it
            continue;
          }
        }
      }

      // Construct and execute the sql
      $field_string = join(',', $fields);
      $value_placeholders = join(',', array_fill(0,count($fields), "'%s'"));
      db_query("INSERT INTO {{$vertex_table}}({$field_string})
        VALUES({$value_placeholders})", $values);
    }

    // Check for the currently active vertex, set dirty if changed
    $active_vid = 0;
    $cv_res = db_query_range("SELECT vid FROM {{$vertex_table}}
      WHERE pid = %d
      AND valid_from <= %d
      ORDER BY valid_from DESC", $dbp->pid, time(), 0, 1);
    if ($o = db_fetch_object($cv_res)) {
      $active_vid = $o->vid;
    }

    // Update current vid if needed
    if ($active_vid != $dbp->vid) {
      db_query('UPDATE {datapoint} SET vid=%d WHERE pid=%d',
        $active_vid, $dbp->pid);
    }
  }
}

/**
 * Gets a vertex
 *
 * @return void
 **/
function datapoint_vertex($source, $vid) {
  $vertex_table = $source['parser'] . '_vertex';
  $res = db_query("SELECT * FROM {{$vertex_table}} WHERE vid = %d", $vid);
  if ($vertex = db_fetch_object($res)) {
    return $vertex;
  }
  return FALSE;
}

/**
 * Updates the nodes for all data points that've been marked as dirty
 *
 * @return void
 **/
function datapoint_update_nodes() {
  // Get a maximum of fifty dirty datapoints that should have nodes updated or created
  $dirty_res = db_query_range("SELECT * FROM {datapoint} WHERE dirty=1", 0, 50);

  while($dbp = db_fetch_object($dirty_res)) {
    if (!empty($dbp->data)) {
      $dbp->data = unserialize($dbp->data);
    }
    else {
      $dbp->data = array();
    }
    $source = datapoint_source($dbp->sid);
    if ($source) {
      $vertex = datapoint_vertex($source, $dbp->vid);
      if ($vertex) {
        datapoint_update_node($source, $dbp, $vertex);
      }
    }
  }
}

/**
 * Updates a node with the information from a datapoint
 * This also sets the node association and active vertex for data points
 *
 * @return void
 **/
function datapoint_update_node($source, $datapoint, $vertex) {
  $source_type = datapoint_source_type($source['type']);

  $node = NULL;
  if ($datapoint->nid) {
    $node = node_load($datapoint->nid);
  }
  if (!$node) {
    $node = new stdClass();
    $node->type = $source_type['content_type'];

    module_load_include('inc', 'node', 'node.pages');

    // Prepare node object
    node_object_prepare($node);

    // Set the default taxonomy for the source
    $node->taxonomy = $source['taxonomy'];
  }

  $fields = $source_type['fields'];
  $source_fields = datapoint_source_fields($source_type['parser']);
  $managed_fields = datapoint_managed_fields($node->type);

  // Iterate through the fields configured in the source type and
  // get source values and feed them to the setters
  foreach ($fields as $managed_name => $field) {
    $source_name = $field['source'];

    if (isset($managed_fields[$managed_name]) && isset($source_fields[$source_name])) {
      // Get the source definition and execute it's callback
      $source_def = $source_fields[$source_name];
      $value = call_user_func_array($source_def['callback'], array(&$node, $managed_name, $field, $source_def, $datapoint, $vertex));

      // Get the managed definition and execute it's callback
      $managed_def = $managed_fields[$managed_name];
      call_user_func_array($managed_def['setter'], array(&$node, $field, $managed_def, $value));
    }
  }

  node_save($node);

  db_query("UPDATE {datapoint} SET dirty=0, vid=%d, nid=%d WHERE pid=%d", $vertex->vid, $node->nid, $datapoint->pid);

  return $node;
}