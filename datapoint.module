<?php
require_once('datapoint.inc');
require_once('datapoint.vertex-install.inc');

function datapoint_init() {
  $modules = module_implements('datapoint_update');
  foreach ($modules as $module) {
    $results = new DatapointResults();
  }
}

function datapoint_menu() {
  $menu = array();
  $menu['admin/content/datapoint'] = array(
    'title' => 'Data points',
    'page callback' => '_datapoint_admin_index_page',
    'access arguments' => array('administer datapoint sources'),
    'file' => 'datapoint.admin.inc',
    'type' => MENU_NORMAL_ITEM,
  );
  $menu['admin/content/datapoint/add-source'] = array(
    'title' => 'Add new data point source',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('_datapoint_source_add'),
    'access arguments' => array('administer datapoint sources'),
    'file' => 'datapoint.admin.inc',
    'type' => MENU_NORMAL_ITEM,
  );
  $menu['admin/content/datapoint/source-types'] = array(
    'title' => 'Source types',
    'page callback' => '_datapoint_admin_source_types',
    'access arguments' => array('administer datapoint sources'),
    'file' => 'datapoint.admin.inc',
    'type' => MENU_NORMAL_ITEM,
  );
  $menu['admin/content/datapoint/source-types/add'] = array(
    'title' => 'Add source type',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('_datapoint_admin_add_source_type'),
    'access arguments' => array('administer datapoint sources'),
    'file' => 'datapoint.admin.inc',
    'type' => MENU_NORMAL_ITEM,
  );
  $menu['admin/content/datapoint/source-types/add/%/%'] = array(
    'title' => 'Source type settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('_datapoint_admin_add_source_type_configure', 5, 6),
    'access arguments' => array('administer datapoint sources'),
    'file' => 'datapoint.admin.inc',
    'type' => MENU_CALLBACK,
  );

  $menu['admin/content/datapoint/update-nodes'] = array(
    'page callback' => 'datapoint_update_nodes',
    'access arguments' => array('administer datapoint sources'),
  );

  // Ping
  // TODO: The ping should not point directly to the update_source function, rather it should do some checks against last update and schedule a on cron update or trigger a direct update accordingly.
  $menu['datapoint/ping/%'] = array(
    'page callback' => 'datapoint_update_source',
    'page arguments' => array(2),
    'access arguments' => array('datapoint use ping'),
    'file' => 'datapoint.admin.inc',
  );

  // Ahah callbacks
  $menu['datapoint/ahah/field-source-configuration/%/%'] = array(
    'page callback' => 'datapoint_ahah_field_source_configuration',
    'page arguments' => array(3, 4),
    'access arguments' => array('administer datapoint sources'),
    'file' => 'datapoint.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $menu['datapoint/ahah/source_configuration'] = array(
    'page callback' => 'datapoint_ahah_source_configuration',
    'access arguments' => array('administer datapoint sources'),
    'file' => 'datapoint.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $menu['datapoint/ahah/custom-node-configuration'] = array(
    'page callback' => 'datapoint_ahah_custom_node_configuration',
    'page arguments' => array(3, 4),
    'access arguments' => array('administer datapoint sources'),
    'file' => 'datapoint.admin.inc',
    'type' => MENU_CALLBACK,
  );

  return $menu;
}

function datapoint_perm() {
  return array('administer datapoint sources');
}

function datapoint_source_fields($parser) {
  static $cache = array();

  if (!isset($cache[$parser])) {
    $schema = datapoint_vertex_module_schema($parser);
    $schema_fields = $schema[$parser . '_vertex']['fields'];

    $source_fields = array(
      'datapoint_name' => array(
        'callback' => '_datapoint_source_fields',
        'description' => t('The name of the data point'),
      ),
      'datapoint_external_id' => array(
        'callback' => '_datapoint_source_fields',
        'description' => t('The external id for the data point'),
      ),
    );

    foreach ($schema_fields as $key => $column) {
      $source_fields['vertex_schema_' . $key] = array(
        'description' => $column['description'],
        'callback' => '_datapoint_source_fields',
        'vertex_attribute' => $key,
      );
    }

    drupal_alter('datapoint_source_fields', $source_fields, $parser);
    $cache[$parser] = $source_fields;
  }

  return $cache[$parser];
}

function _datapoint_source_fields(&$node, $field_name, $field, $source, $datapoint, $vertex) {
  switch ($field['source']) {
    case 'datapoint_name':
      return $datapoint->name;
    break;
    case 'datapoint_external_id':
      return $datapoint->external_id;
    break;
    default:
      // Check if this simply is a reference to a vertex attribute
      // TODO: Maybe this could be a viable method to get the datapoint attributes too
      if (isset($source['vertex_attribute'])) {
        $a = $source['vertex_attribute'];
        if (isset($vertex->$a)) {
          return $vertex->$a;
        }
      }
    break;
  }
}

/**
 * Loads the data point source type
 *
 * @return array Source type configuration
 **/
function datapoint_source_type($type) {
  $res = db_query("SELECT configuration FROM {datapoint_source_type} WHERE type='%s'", $type);
  if ($source = db_fetch_object($res)) {
    return unserialize($source->configuration);
  }
  return FALSE;
}

/**
 * Loads a data point source
 *
 * @return array Source configuration
 **/
function datapoint_source($sid) {
  static $cache = array();

  if (!isset($cache[$sid])) {
    $res = db_query("SELECT configuration FROM {datapoint_source} WHERE sid='%d'", $sid);
    if ($o = db_fetch_object($res)) {
      $source = unserialize($o->configuration);
      $source['sid'] = $sid;
      $cache[$sid] = $source;
    }
    else {
      return FALSE;
    }
  }

  return $cache[$sid];
}

function datapoint_by_external_id($source, $id) {
  $res = db_query("SELECT * FROM {datapoint} WHERE sid=%d AND external_id='%s'", $source, $id);
  if ($point = db_fetch_object($res)) {
    return $point;
  }
  return FALSE;
}

/**
 * Saves a source type configuration in the database
 *
 * @return void
 **/
function datapoint_add_source_type($configuration) {
  db_query("INSERT INTO {datapoint_source_type}(type, name, configuration) VALUES('%s','%s','%s')",
    $configuration['type'], $configuration['name'], serialize($configuration));
}

/**
 * Saves a source in the database
 *
 * @return void
 **/
function datapoint_add_source($configuration) {
  db_query("INSERT INTO {datapoint_source}(source_type, name, last_update, configuration)
    VALUES('%s','%s',0,'%s')",
    $configuration['type'], $configuration['name'], serialize($configuration));
}

/**
 * Gets the defined source types as a associative array type=>name
 *
 * @return void
 **/
function datapoint_source_types() {
  $types = array();
  $res = db_query("SELECT type, name FROM {datapoint_source_type}");
  while ($o = db_fetch_object($res)) {
    $types[$o->type] = $o->name;
  }
  return $types;
}

/**
 * Gets the fields that datapoint feeds can access in nodes of specific type
 *
 * @return void
 **/
function datapoint_managed_fields($content_type) {
  static $cache = array();

  if (!isset($cache[$content_type])) {
    $type = node_get_types('type', $content_type);
    $fields = array();
    drupal_alter('datapoint_managed_fields', $fields, $type);

    return $cache[$content_type] = $fields;
  }

  return $cache[$content_type];
}

/**
 * Implementation of hook_datapoint_managed_fields_alter
 *
 * @return void
 **/
function datapoint_datapoint_managed_fields_alter(&$fields, $type) {
  if ($type->has_title) {
    $fields['title'] = array(
      'label' => $type->title_label,
      'required' => TRUE,
      'setter' => '_datapoint_set_node_title',
    );
  }
  if ($type->has_body) {
    $fields['body'] = array(
      'label' => $type->body_label,
      'required' => $type->min_word_count>0,
      'setter' => '_datapoint_set_node_body',
    );
  }
}

function _datapoint_set_node_title(&$node, $field, $value) {
  $node->title = $value;
}

function _datapoint_set_node_body(&$node, $field, $value) {
  $node->body = $value;
}

/**
 * Helper function to fetch data from a url for a parser
 *
 * TODO: This function should be enhanced with some header stuff like etag & updated since. We should stop unchanged data from reaching the parser based on some md5 or crc check.
 *
 * @return void
 **/
function datapoint_url_fetch($url, $source, &$result, $callback) {
  // This function initializes CURL, sets the necessary CURL
  // options, executes the request and returns the results.
  $ch = curl_init();
  curl_setopt($ch, CURLOPT_URL, $url);
  curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
  $data = curl_exec($ch);
  curl_close($ch);

  call_user_func($callback, $data, $source, $result);
}

/**
 * Stores the $results for the $source. If you want to add data points and vertexes
 * programmatically this is the place to do it.
 *
 * @return void
 **/
function datapoint_store($source, &$results) {
  require_once(drupal_get_path('module', 'datapoint') . '/datapoint.vertex-install.inc');
  $vertex_table = $source['parser'] . '_vertex';

  foreach($results as $extid => $point) {
    $dbp = datapoint_by_external_id($source['sid'], $extid);

    // If the data point exists in the database
    if ($dbp) {
      // ...delete vertexes that overlap or are later than what we're currently adding
      db_query("DELETE FROM {{$vertex_table}} WHERE pid=%d AND valid_from>=%d",
        $dbp->pid, $point->getStartTime());
    }
    else {
      // ...otherwise we just want to add the datapoint
      db_query("INSERT INTO {datapoint}(sid, external_id, name) VALUES(%d, '%s', '%s')",
        $source['sid'], $extid, $point->getName());
      $dbp = datapoint_by_external_id($source['sid'], $extid);
    }

    // The schema information for the parser is needed to create vertexes
    $schema = datapoint_vertex_module_fields($source['parser']);

    foreach ($point as $vertex) {
      $attr = $vertex->getValues();

      // Set up our field & values arrays with the two default columns
      $fields = array('pid', 'valid_from');
      $values = array($dbp->pid, $vertex->getTime());

      // Iterate through the vertex columns
      foreach ($schema['fields'] as $cname => $cdef) {
        if (isset($attr[$cname])) { //Attributes that are provided should always be added
          $fields[] = $cname;
          $values[] = $attr[$cname];
        }
        // If no value was provided and the column is required
        else if (isset($cdef['not null']) && $cdef['not null']) {
          if (isset($cdef['default'])) { // We're saved by a default value
            $fields[] = $cname;
            $values[] = $cdef['default'];
          }
          else { // The vertex is not valid so we're skipping it
            continue;
          }
        }
      }

      // Construct and execute the sql
      $field_string = join(',', $fields);
      $value_placeholders = join(',', array_fill(0,count($fields), "'%s'"));
      db_query("INSERT INTO {{$vertex_table}}({$field_string})
        VALUES({$value_placeholders})", $values);
    }

    // Check for the currently active vertex, set dirty if changed
    $active_vid = 0;
    $cv_res = db_query_range("SELECT vid FROM {{$vertex_table}}
      WHERE pid = %d
      AND valid_from <= %d
      ORDER BY valid_from DESC", $dbp->pid, time(), 0, 1);
    if ($o = db_fetch_object($cv_res)) {
      $active_vid = $o->vid;
    }

    if ($active_vid != $dbp->vid) { // We don't need to do anything if the vid is unchanged
      // We only set the dirty-flag if we actually have a vertex to update with
      // otherwise the node should be left unchanged.
      $dirty = $active_vid ? 1 : 0;
      db_query('UPDATE {datapoint} SET vid=%d, dirty=%d WHERE pid=%d',
        $active_vid, $dirty, $dbp->pid);
    }
  }
}

function datapoint_vertex($source, $vid) {
  $vertex_table = $source['parser'] . '_vertex';
  $res = db_query("SELECT * FROM {{$vertex_table}} WHERE vid = %d", $vid);
  if ($vertex = db_fetch_object($res)) {
    return $vertex;
  }
  return FALSE;
}

function datapoint_update_nodes() {
  // Get a maximum of fifty dirty datapoints that should have nodes updated or created
  $dirty_res = db_query_range("SELECT * FROM {datapoint} WHERE dirty=1", 0, 50);

  while($dbp = db_fetch_object($dirty_res)) {
    $source = datapoint_source($dbp->sid);
    if ($source) {
      $vertex = datapoint_vertex($source, $dbp->vid);
      if ($vertex) {
        datapoint_update_node($source, $dbp, $vertex);
      }
    }
  }
}

function datapoint_update_node($source, $datapoint, $vertex) {
  $source_type = datapoint_source_type($source['type']);

  $node = NULL;
  if ($datapoint->nid) {
    $node = node_load($datapoint->nid);
  }
  if (!$node) {
    $node = new stdClass();
    $node->type = $source_type['content_type'];

    module_load_include('inc', 'node', 'node.pages');

    // Prepare node object
    node_object_prepare($node);

    // Set the default taxonomy for the source
    $node->taxonomy = $source['taxonomy'];
  }
  
  $fields = $source_type['fields'];
  $source_fields = datapoint_source_fields($source_type['parser']);
  $managed_fields = datapoint_managed_fields($node->type);
  
  // Iterate through the fields configured in the source type and 
  // get source values and feed them to the setters
  foreach ($fields as $managed_name => $field) {
    $source_name = $field['source'];
    
    if (isset($managed_fields[$managed_name]) && isset($source_fields[$source_name])) {
      // Get the source definition and execute it's callback
      $source_def = $source_fields[$source_name];
      $value = call_user_func_array($source_def['callback'], array(&$node, $managed_name, $field, $source_def, $datapoint, $vertex));
      
      // Get the managed definition and execute it's callback
      $managed_def = $managed_fields[$managed_name];
      call_user_func_array($managed_def['setter'], array(&$node, $field, $value));
    }
  }
  
  node_save($node);
  
  db_query("UPDATE {datapoint} SET dirty=0, vid=%d, nid=%d WHERE pid=%d", $vertex->vid, $node->nid, $datapoint->pid);
  
  return $node;
}